{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/future-proofed-hashes-with-multihash","webpackCompilationHash":"e6ea3bbe3ddca9ef95da","result":{"data":{"markdownRemark":{"id":"4ab69166-3152-5871-98ee-155b2411f798","html":"<p>‚Äù</p>\n<p>Let‚Äôs talk about hashes.</p>\n<p>As mentioned in the resurrecting <a href=\"a-new-start\">post about starting new</a>, I‚Äôd like to document my learnings as I‚Äôm diving into projects that catch my attention in the decentralization space, such as <a href=\"https://ipfs.io\" title=\"IPFS website\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IPFS</a>. If you aren‚Äôt familiar with IPFS or haven‚Äôt heard of it, it‚Äôs basically a stack of (networking) protocols that enables a fully distributed file storage system to creates a faster, safer and more reliable web.</p>\n<p>Hashes play a big role in IPFS as they are used to address content in a distributed network, similar to how <a href=\"https://git-scm.com\" title=\"Git website\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git</a> uses hashes to address commits, trees and binary objects inside a repository (yep, you probably use them on a daily basis, without noticing).</p>\n<p>When a system relies on cryptographic hashes as fundamental building blocks, it‚Äôs pretty important to have an update strategy in mind in case the hash algorithms used are considered weak or insecure at some point. In this post I‚Äôd like to explore <strong>how the IPFS project takes advantage of ‚ÄúMultihashes‚Äù</strong> to ensure hashes are upgradable and can co-exist in the same application.</p>\n<h3 id=\"so-what-are-hashes-again\"><a href=\"#so-what-are-hashes-again\" aria-label=\"so what are hashes again permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>So‚Ä¶ what are hashes again?</h3>\n<p>Right, let‚Äôs get this out of our way quickly. A hash is actually less scary than it sounds. It is really just a function that takes some arbitrary input and returns a fixed-size alphanumeric string. What that alphanumeric string looks like depends on the given hash algorithm.</p>\n<p>Let‚Äôs make up a simple hash function and say we have a message ‚Äúabc‚Äù which is our input. Our custom hash function‚Äôs algorithm takes every character of the input message and moves it forward three letters in the alphabet. This will result in a hash digest ‚Äúdef‚Äù.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HASH(&#39;abc&#39;) // &#39;def&#39;</code></pre></div>\n<p>There it is. A hash.</p>\n<p>Now, if we look at some real world hash functions, they do exactly the same thing (just that the algorithm is more complex obviously). Git for example uses SHA-1, which produces a 160 bit hash, <a href=\"https://crypto.stackexchange.com/questions/34995/why-do-we-use-hex-output-for-hash-functions\" title=\"Why do we use hex output for hash functions?\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">usually rendered as a hexadecimal number</a>, 40 digits long. It hashes raw content (binary data), tree objects and commits.</p>\n<p>If you have Git installed on your machine, try it yourself! Simply run the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ echo &quot;abc&quot; | git hash-object --stdin</code></pre></div>\n<p>The returned digest is <code class=\"language-text\">8baef1b4abc478178b004d62031cf7fe6db6f903</code>. And yes, a hash algorithm will always return the same hash for a given input. That‚Äôs how you can verify integrity when you receive data from a sender. However, it is impossible to derive the input from a hash. Super important characteristic.</p>\n<p>To be accurate here, it turns out that Git doesn‚Äôt actually hash the raw input, but prepends the input with <code class=\"language-text\">blob</code> followed by the size of the content before hashing. This isn‚Äôt important right now, but just in case you‚Äôre trying to verify the digest with e.g. OpenSSL‚Äôs SHA-1 implementation, you‚Äôll notice it‚Äôll return a different hash from ‚Äòabc‚Äô.</p>\n<p>Also, if you <strong>do</strong> want to dig deeper (like me), check out <a href=\"https://stackoverflow.com/questions/552659/how-to-assign-a-git-sha1s-to-a-file-without-git/552725#552725\" title=\"How Git calculates the SHA1 for a file\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this StackOverflow answer</a>.</p>\n<p>The bottom line is:</p>\n<ul>\n<li>Hashes are the result of an algorithm transforming an input to a digest</li>\n<li>Algorithms return a fixed length (e.g. SHA1 returns 160 bit hashes)</li>\n<li>They always return the same hash value for a given input</li>\n<li>It is (or should be) impossible to derive the input from a hash</li>\n</ul>\n<p>Okay, coming back to this ‚ÄúMultihashes‚Äù thing‚Ä¶</p>\n<h3 id=\"the-problem-with-hashes\"><a href=\"#the-problem-with-hashes\" aria-label=\"the problem with hashes permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem with hashes</h3>\n<p>Hashes are really great. Due to their characteristics, we can use them to verify the integrity of content and data, plus, they can be very compact as well. Unfortunately though, sometimes they turn out to be not secure or strong enough (I‚Äôm looking at you, <a href=\"https://en.wikipedia.org/wiki/MD5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MD5</a>!), or attackers manage to break them. Not something that happens all the time, but it happened.</p>\n<p>Imagine a simple, but common scenario in which user passwords are stored in some database. Obviously, we don‚Äôt want to store passwords in plain text, that‚Äôd be a disaster for many different reasons I don‚Äôt think I have to mention here. Perfect use case for hashes right? So let‚Äôs go ahead and assume we store those passwords as MD5 hashes. Wonderful, many problems solved with a simple fix.</p>\n<p>Now let‚Äôs say, <em>cough</em> hypothetically <em>cough</em> üôÉ, the next day, <a href=\"https://security.stackexchange.com/questions/19906/is-md5-considered-insecure\" title=\"Is MD5 considered insecure?\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MD5 is considered insecure</a>. What are are going to do? Well, we definitely have to upgrade our hash algorithm to something more secure. That turns out to be a challenge though, because we happen to deal with a large, maybe distributed, system and can only upgrade over time.</p>\n<p>We need to find a way to slowly (but as fast as possible) upgrade to a different hash algorithm, while keeping the existing system in tact.</p>\n<p>Another problem that shouldn‚Äôt get less attention, is that existing systems often rely on APIs that simply assume a certain type of hash and its length. Think about how many Git repositories are out there with every single object being a 160 bit hexadecimal hash (40 digits). Imagine what happens when Git switches to SHA-2, a 256 bit hash and how many tools and applications would break.</p>\n<p>Turns out problems like those can be avoid by introducing a versioning system.</p>\n<h3 id=\"versioned-hashes\"><a href=\"#versioned-hashes\" aria-label=\"versioned hashes permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Versioned hashes</h3>\n<p>The idea is quite simple: introduce some version as part of the hash so the system can easily figure out what hash it is dealing with.</p>\n<p>Let‚Äôs take the ‚Äòabc‚Äô hash we calculated with Git earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">8baef1b4abc478178b004d62031cf7fe6db6f903</code></pre></div>\n<p>If this is a password hash and we‚Äôd have to verify whether it is the correct password or not, we‚Äôd just compare this computed hash with the one in our database. However, as mentioned earlier, we want to migrate to a different hash algorithm without breaking the system. The same input as SHA-256 for example, looks quite different:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD</code></pre></div>\n<p>In order to know up front that we‚Äôre in fact dealing with a different hash version, we ca introduce a version number like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1:BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD</code></pre></div>\n<p>This also works great for systems that already use <em>unversioned</em> hashes. Any hash without a colon must have been created before the version change. Any hash with a colon and version number can be handled in a respective way (stripping out the first two bytes (<code class=\"language-text\">1:</code>) and assume the hash is a SHA-256 hash in this case).</p>\n<p>This solution can be scaled up and down in different ways depending on our needs. For example, if we‚Äôre in a scenario where we happen to deal with more than two hash types, we could introduce versions for each type like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sha1:0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\nsha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\nblake2:a96953281f3fd944a3206219fad61a40b992611b7580f1fa091935db3f7ca13d</code></pre></div>\n<p>In fact, this seems to be <a href=\"https://stackoverflow.com/questions/3955223/password-hashing-how-to-upgrade\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the way to go</a>.</p>\n<p>We can do better though. While the above is a decent way to approach this challenge, there are still some things can turn into problems:</p>\n<ul>\n<li>One obvious characteristic is that the version type might not be compatible with the rest of the hash type. For example <code class=\"language-text\">s</code> is not a valid hexadecimal digit. However, Most systems transfer hashes in hex (or base32, base64 etc). So there‚Äôs added complexity when building apps on top of those schemes.</li>\n<li>In case millions or billions of hashes have to be stored, long version types like <code class=\"language-text\">blake2</code> might have a considerable impact in terms of byte costs. A shorter streamlined version syntax may be better here.</li>\n</ul>\n<p>Okay, now it‚Äôs really time to dive into this Multihash thing.</p>\n<h3 id=\"multihashes\"><a href=\"#multihashes\" aria-label=\"multihashes permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multihashes</h3>\n<p>This is where Multihashes come into play. <a href=\"https://multiformats.io/multihash/\" title=\"Multihash website\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash</a> is a protocol (used by IPFS) for differentiating outputs from various well-established hash functions. It works very similar to what we‚Äôve just done, just that it adds a little bit of extra information in a smart way.</p>\n<p>A Multihash has the following pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;hash-func-type&gt;&lt;digest-length&gt;&lt;digest-value&gt;</code></pre></div>\n<p>Where</p>\n<ul>\n<li>the <code class=\"language-text\">&lt;hash-func-type&gt;</code> describes the hash function used - there‚Äôs a <a href=\"https://github.com/multiformats/multihash/blob/master/hashtable.csv\" title=\"Multihash table\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hash table</a> to see how the codes are mapped</li>\n<li>the <code class=\"language-text\">&lt;digest-length&gt;</code> describes the length of the <code class=\"language-text\">&lt;digest-value&gt;</code> in bytes</li>\n<li>the <code class=\"language-text\">&lt;digest-value&gt;</code> is the actual hash value we‚Äôre interested in</li>\n</ul>\n<p>Okay, let‚Äôs take the following Multihash as an example and try to demystify it</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">122041dd7b6443542e75701aa98a0c235951a28a0d851b11564d20022ab11d2589a8</code></pre></div>\n<p><strong>Notice</strong>: In hexadecimal code, two digits are equal to one byte. In other words, the first two digits, <code class=\"language-text\">12</code>, can be translated to <code class=\"language-text\">0001 0010</code>. That‚Äôs why a 160 bit hash in hex code is a 40 digit number. Also, usually hex codes are prepended with <code class=\"language-text\">0x</code> to indicate that it‚Äôs a hex code. In this case <code class=\"language-text\">0x12</code> and <code class=\"language-text\">12</code> are the same thing.</p>\n<p>We‚Äôve learned that the first byte identifies the hash function type. According to the <a href=\"https://github.com/multiformats/multihash/blob/master/hashtable.csv\" title=\"Multihash table\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash table</a>, that would be <code class=\"language-text\">sha2-256</code> (take a look yourself, it‚Äôs in the seventh row).</p>\n<p>Next up, the digest length (also in bytes). <code class=\"language-text\">0x20</code> is <code class=\"language-text\">32</code> in decimal, so at this point we already know the following hash value is 32 bytes (256 bits) long.</p>\n<p>This is an important information to have. Remember the scenario where Git would switch from SHA-1 to SHA-256 ? Many apps and systems that work with Git hashes expect them to be 160 bit long. If Git used something like Multihash, apps could simply read out the length of the expected hash and keep it therefore variable.</p>\n<p>Last but not least, the actual hash digest we‚Äôre dealing with <code class=\"language-text\">41dd7b6443542e75701aa98a0c235951a28a0d851b11564d20022ab11d2589a8</code>.</p>\n<p>Pretty cool, we basically have a single hash that is <strong>completely self-describing</strong> and still addressable as it keeps the characteristics of any other cryptographic hash.</p>\n<p>Using the Multihash protocol these days is very easy as well. There are <a href=\"https://multiformats.io/multihash/#implementations\" title=\"Multihash implementations\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">implementations for several languages</a> like Go, Java, Rust, JavaScript and more! If you want to learn about Multihashes and the IPFS protocol stack (yes, there‚Äôs so much more), here are some resources:</p>\n<ul>\n<li><a href=\"https://github.com/jbenet/random-ideas/issues/1\" title=\"Initial RFC for Multihash\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RFC: Future-proofed cryptographic hash values by Juan Benet</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Bqs_LzBjQyk\" title=\"Talk about IPLD\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Talk: Enter the Merkle Forest by Juan Benet</a></li>\n<li><a href=\"https://multiformats.io/multihash/\" title=\"Multihash website\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash Website</a></li>\n</ul>\n<p>Happy multihashing!</p>","fields":{"slug":"/posts/future-proofed-hashes-with-multihash","tagSlugs":null},"frontmatter":{"date":"2018-07-11T07:00:20.000Z","description":"Let's talk about hashes and how we can make them future-proof using the Multihash protocol.","tags":null,"title":"On future-proof cryptographic hashes"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/future-proofed-hashes-with-multihash"}}}