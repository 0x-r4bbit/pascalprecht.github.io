{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/integrating-web-components-with-angularjs/","webpackCompilationHash":"e6ea3bbe3ddca9ef95da","result":{"data":{"markdownRemark":{"id":"b1c250bf-47da-5944-a181-37a91f332077","html":"<p>Just a few days ago I had the honour to give a talk together with the awesome <a href=\"http://twitter.com/CarmenPopoviciu\">Carmen</a> at the first european <a href=\"http://angularjs.org\">AngularJS</a> conference <a href=\"http://ngeurope.org\">ngEurope</a>. The title of our talk was:</p>\n<p><i>“Don’t stop thinking about tomorrow! - AngularJS and Web Components”</i></p>\n<p>We talked about what Web Components are and if and how we can integrate them with the AngularJS of today, since this is a question that seems to be asked quiet often. We also talked about Angular 2.0 and how that version of the framework will embrace the Web Components technologies, so we had a nice overview of what issues can occur and how they are solved in the future. If you’re interested in the talk, the slides are up online <a href=\"http://pascalprecht.github.io/dont-stop-thinking-about-tomorrow\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> and there’s also <s>going to be</s> a video on <a href=\"https://www.youtube.com/watch?v=gSTNTXtQwaY\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Youtube</a>. <s>I’ll update this post, once it’s online.</s></p>\n<p>However, as you can probably imagine, 25 minutes are not enough to cover everything in detail about Web Components, the Angular of today and the Angular of tomorrow. This is why I decided to write a follow up article on what we’ve been talking about, to focus more on the things that probably missed out. I’ll not cover the Web Components technologies themselves since there are tons of resources out there in the web. This article focuses on the <strong>integration of Web Components with the AngularJS</strong> of today and the AngularJS of tomorrow.</p>\n<h2 id=\"building-a-simple-web-component\"><a href=\"#building-a-simple-web-component\" aria-label=\"building a simple web component permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Building a simple web component</h2>\n<p>Let’s jump right into the topic and say we’ve built a web component that looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>special-input</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Hello<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>special-input</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>You can probably imagine that this web component is evidently a sort of input element, that does a better job than the native <code class=\"language-text\">&lt;input type=&quot;text&quot;&gt;</code> element. However, here’s what the implementation of it might look like, we start with the template (I don’t use Polymer in order to make clear that the stuff you read here should work with any web component, regardless if it’s implemented with a library like Polymer or not, as long as a few requirements are fulfilled. But we’ll get into this in a minute):</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Ground breaking hm? As you can see, all we do is having an <code class=\"language-text\">&lt;input type=&quot;text&quot;&gt;</code> element in our template, however, you know we could do much more here. But for the sake of simplicity, we stick with this example.</p>\n<p>Next, the custom element definition:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> SpecialInputProto <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HTMLElement</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nSpecialInputProto<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">createdCallback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// getting initial value of value attribute</span>\n  <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">hasAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span>\n              <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> template <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'template'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// setting value property of input element</span>\n  template<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> shadowRoot <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">createShadowRoot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  shadowRoot<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">cloneNode</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Okay, so our <code class=\"language-text\">SpecialInputProto</code> prototype creates its own shadow root, checks for an initial <code class=\"language-text\">value</code> attribute and feeds the templates <code class=\"language-text\">&lt;input&gt;</code> with it. Finally it activates its template by cloning its contents into its Shadow DOM. Last but not least, we have to register our new custom element on the document:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">document<span class=\"token punctuation\">.</span><span class=\"token function\">registerElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'special-input'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  prototype<span class=\"token punctuation\">:</span> SpecialInputProto\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Great, our web component is now ready to use. But can we use it in an Angular app?</p>\n<h2 id=\"web-components-inside-angular-world\"><a href=\"#web-components-inside-angular-world\" aria-label=\"web components inside angular world permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Components inside Angular world</h2>\n<p>Being able to build our own web components is of course a nice thing. However, coming from an Angular world, the first question that probably comes into our minds is, if we’re able to actually use this component in our Angular apps, even if it’s not a directive but a custom element.</p>\n<p>Unfortunately it’s not possible to say that it works out of the box per se and at the same time, it wouldn’t be fair to say that it’s not possible at all. Let’s go through all possible scenarios and see if we can find an answer. We start with the most simplest one: Using our web component in our Angular app.</p>\n<p>Let’s say we have some HTML code that looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ng-controller</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>AppController<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">></span></span>Please enter your name:<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>special-input</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Pascal<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>special-input</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Pretty straight forward. We have a controller that creates a scope with an associated DOM element. What we also see is the usage of our fresh created web component with a hard coded <code class=\"language-text\">value</code> attribute. Now the big question:</p>\n<p><strong>Does that work?</strong></p>\n<p>The answer is yes. And Carmen explained very well in the talk why:</p>\n<blockquote>\n<p>Everything is DOM. Angular doesn’t know and shouldn’t know about custom elements.</p>\n</blockquote>\n<p>In fact, Angular doesn’t even pick up our custom element since it’s not registered as directive and therefore not collected by the compiler. So for that simple case, we can just use our custom element. Also the <code class=\"language-text\">value</code> attribute is just a hard coded string, there’s nothing special with our custom element from the outside world so things do just work.</p>\n<p>Okay, fair enough but what happens when we assign an actual model value to our scope and use that to feed our custom element with data? Well, let’s take a look. First, the controller:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">angular<span class=\"token punctuation\">.</span><span class=\"token function\">module</span><span class=\"token punctuation\">(</span><span class=\"token string\">'myApp'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">controller</span><span class=\"token punctuation\">(</span><span class=\"token string\">'AppController'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">$scope</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  $scope<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Pascal'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Next we apply the interpolation directive to our <code class=\"language-text\">&lt;special-input&gt;</code> element like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ng-controller</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>AppController<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">></span></span>Please enter your name:<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>special-input</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{{name}}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>special-input</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>What happens now? Executing this code in our browser shows us, that our <code class=\"language-text\">&lt;special-input&gt;</code> element gets <code class=\"language-text\">{{name}}</code> as string value and that’s it. It seems like the interpolation didn’t happen at all. The reason for that is, that our custom element doesn’t react on attribute changes yet. It gets the initial value, which is in fact <code class=\"language-text\">{{name}}</code> and when the interpolation happens, it doesn’t update the <code class=\"language-text\">value</code> property of the <code class=\"language-text\">&lt;input&gt;</code> element inside the Shadow DOM.</p>\n<p>We can fix that by extending our <code class=\"language-text\">SpecialInputProto</code> with an <code class=\"language-text\">attributeChangedCallback</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">SpecialInputProto<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">attributeChangedCallback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> oldValue<span class=\"token punctuation\">,</span> newValue</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name <span class=\"token operator\">===</span> <span class=\"token string\">'value'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>shadowRoot<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now, everytime the value of the <code class=\"language-text\">value</code> attribute of our custom element changes, it updates the <code class=\"language-text\">value</code> property of its Shadow DOM <code class=\"language-text\">input</code>. If we run the example in our browser again, we see that our custom element picks up the change at runtime and is updated accordingly.</p>\n<p>We just experienced the first important fact when it comes to integrating web components with Angular: if the web component doesn’t take care of reflecting attribute changes to corresponding properties, in our case the <code class=\"language-text\">value</code> property of the <code class=\"language-text\">&lt;input&gt;</code> element in the Shadow DOM, changes from the outside world do no appear inside the element. When building web components with Polymer, you don’t have to care about that logic, since it comes with built-in template binding that does the job for you.</p>\n<p>Okay, so now our custom element works even with interpolated attribute values in our Angular app. But does it work the other way around too? Are changes, that happen inside our custom element, reflected back to our model on the controllers scope?</p>\n<p>Let’s try it out and extend our example by adding another <code class=\"language-text\">&lt;input&gt;</code> element to our HTML that has a <code class=\"language-text\">ng-model</code> directive that is bound to our models <code class=\"language-text\">name</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ng-controller</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>AppController<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">></span></span>Please enter your name (directive):<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ng-model</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">></span></span>Please enter your name (web component):<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>special-input</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{{name}}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>special-input</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Typing into our <code class=\"language-text\">input</code> directive triggers a <code class=\"language-text\">$digest</code> in the Angular world and updates the DOM, which in turn reflects the change in our custom element as well. But that we knew already. What happens when we type into our custom element? Yikes! The change happens <strong>inside</strong> our custom element, which at the same time is <strong>outside</strong> the Angular world, so Angular isn’t notified about the change. There’s no <code class=\"language-text\">$digest</code> triggered and our model isn’t updated. This again, brings us back to what Carmen said at ngEurope:</p>\n<blockquote>\n<p>Everything is DOM. Angular doesn’t know and shouldn’t know about custom elements.</p>\n</blockquote>\n<p>In other words, it’s the elements job to notify the outside world when a change happens inside the element. Which brings up the next big question: How can an element notify the outside world? To answer this question, we first have to understand what APIs an element provides.</p>\n<h2 id=\"understanding-the-api-of-an-element\"><a href=\"#understanding-the-api-of-an-element\" aria-label=\"understanding the api of an element permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Understanding the API of an element</h2>\n<p>Every DOM element, no matter if native or custom, comes with four different APIs that developers can use to interact with it:</p>\n<ul>\n<li>Attributes</li>\n<li>Properties</li>\n<li>Methods</li>\n<li>Events</li>\n</ul>\n<p>Let’s explore these for a minute.</p>\n<p><strong>Attributes</strong> are the things we either use declaratively, when we write HTML code and tell our <code class=\"language-text\">&lt;input&gt;</code> element what its initial <code class=\"language-text\">value</code>, or an <code class=\"language-text\">&lt;img&gt;</code> element what its <code class=\"language-text\">src</code> is, or imperatively using an elements <code class=\"language-text\">.setAttribute()</code> method. Attribute values are always interpreted as strings. So it’s not possible to set for example an object as attribute. Some native attributes update their corresponding property once they are set. For example, setting an <code class=\"language-text\">input</code> elements <code class=\"language-text\">value</code> attribute, updates its property with the same value.</p>\n<p><strong>Properties</strong> are the actual DOM object properties we can access imperatively through JavaScript. Every DOM object comes with its default properties but we are of course able to just define new properties on an object if we want. Properties also can have different values that just string. The following code updates the value of an inputs <code class=\"language-text\">value</code> property:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> input <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninput<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">'new value!'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Element properties are not necessarily reflected back to their attributes. Some element properties do, some don’t. The value of an <code class=\"language-text\">input</code> elements <code class=\"language-text\">value</code> property does not reflect back to its attribute. An <code class=\"language-text\">img</code> elements <code class=\"language-text\">src</code> property does. Which means, if we set the value declaratively to <code class=\"language-text\">value=&quot;Pascal&quot;</code> and update the elements property to <code class=\"language-text\">&quot;Carmen&quot;</code>, the attributes value is still <code class=\"language-text\">&quot;Pascal&quot;</code>. It’s also important to mention that, whereas element attributes are used to set initial values, properties are used to update values at runtime. Of course, this only works if there’s a corresponding property to an attribute.</p>\n<p><strong>Methods</strong> can also be accessed imperatively by invoking them directly on an elements DOM object like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\np<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hello there'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Events</strong> are the things we listen to when we want to react on things like <code class=\"language-text\">click</code>, <code class=\"language-text\">focus</code> or <code class=\"language-text\">input</code>. In fact, events are are the only natural way of an element to notify the outside world that something happened inside, like when an element is clicked or an inputs value changed.</p>\n<p>Keep in mind that it’s always up to the element what its inner workings are and if it does things like (custom) event dispatching or attribute/property reflection or not. Now that we know what an elements APIs are, let’s see what we can do to inform Angular about changes in our custom element.</p>\n<h2 id=\"notifying-the-outside-world\"><a href=\"#notifying-the-outside-world\" aria-label=\"notifying the outside world permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Notifying the outside world</h2>\n<p>Taking a look at the APIs that an element comes with, it’s pretty much obvious what we can do to inform Angular about changes that happen inside our custom element, right? Dispatching a custom event like <code class=\"language-text\">valueChanged</code> everytime the <code class=\"language-text\">input</code> element of our custom elements Shadow DOM is updated seems to be the way to go. But what does that mean from the outside world point of view? What do we have to do to actually react on such custom event that is fired in order to call <code class=\"language-text\">$scope.$apply</code> to trigger <code class=\"language-text\">$digest</code>?</p>\n<p>Right. We have to create a new directive for that particular event, otherwise we’re not able to listen to it ”<em>The Angular Way</em>”. And now imagine a custom element dispatches four different events depending on what happens. We would have to build four different directives for every single custom event. Next, multiply this with the amount of different custom elements you use in your Angular app. I think you get the idea.</p>\n<p>So what else can we do to notify Angular? The Angular of today is not able to track changes on custom element properties. It also doesn’t see any attribute changes. It seems hopeless…</p>\n<p><strong>But wait, the internet has this thing called <a href=\"https://developer.mozilla.org/en/docs/Web/API/MutationObserver\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mutation Observer</a>!</strong></p>\n<p>Mutation Observers can be used to observe mutations on the DOM. This includes things like insertions or removals of DOM elements, but also attribute changes. That means, we can create an observer that observes an elements attributes and whenever the observer sees a change, we can run <code class=\"language-text\">$scope.$apply()</code> to inform Angular about this particular change.</p>\n<p>It turns out we don’t even have to build such a thing ourselves. <a href=\"https://github.com/eee-c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chris Strom</a> already built a directive called <a href=\"https://github.com/eee-c/angular-bind-polymer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">angular-bind-polymer</a> that does exactly what we need. It sets up mutation observers for all attributes that have an interpolation directive applied on that particular element, and triggers a <code class=\"language-text\">$scope.$apply()</code> whenever a change on one of these attributes happens.</p>\n<p>All we have to do is to apply the <code class=\"language-text\">bind-polymer</code> directive (yes, the name sounds Polymer specific, but it isn’t. I’ll tell you why in a minute) to the custom element that interacts with our Angular app:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>special-input</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{{name}}<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">bind-polymer</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>special-input</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Weird. It seems that typing into our custom elements <code class=\"language-text\">input</code> still doesn’t notify the outside world about its changes. Why that? Well, if we look closely, we see that we actually forgot something. The <code class=\"language-text\">bind-polymer</code> directive sets up observers that observe changes on the elements attribute, but our custom element doesn’t reflect changes back to its attributes when we type into its <code class=\"language-text\">input</code>. That means, the observers callback isn’t called at all and no <code class=\"language-text\">$digest</code> is triggered. So what do we have to do?</p>\n<p>In order to trigger the applied mutation observers, we have to make sure, that the changes are actually reflected back to the elements attribute. In our particular case that means, we have to set the <code class=\"language-text\">value</code> attribute of <code class=\"language-text\">special-input</code> whenever its <code class=\"language-text\">input</code> fires an <code class=\"language-text\">input</code> event. Let’s update the <code class=\"language-text\">createdCallback()</code> of our <code class=\"language-text\">SpecialInputProto</code> accordingly:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">SpecialInputProto<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">createdCallback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// ... creating shadow root etc...</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>shadow<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>After we cloned the templates contents into our Shadow DOM, we query its <code class=\"language-text\">input</code> element and set up an event listener that updates our custom elements <code class=\"language-text\">value</code> attribute whenever a change in the <code class=\"language-text\">input</code> happens.</p>\n<p>Phew. That’s it. Typing into our custom element now triggers a <code class=\"language-text\">$digest</code> that syncronizes the scopes model.</p>\n<p>This brings us to the next important fact when integrating web components with Angular: when relying on attribute changes with mutation observers, syncronization only works when the custom element reflects changes back to its attributes. In addition, from a custom element point of view and despite from the fact that it’s probably going to be used in an Angular app, there’s no real reason to reflect property values back to its attributes except for styling.</p>\n<p>That’s also the reason why the README of the angular-bind-polymer project says ”<em>This only works with Polymer elements that use reflection</em>”. Polymer comes with an API that lets you easily set up attribute/property reflection. All you have to do is to set <code class=\"language-text\">reflect: true</code> in a properties configuration and Polymer does the rest for you. That’s probably also be the reason why the project has a Polymer specific name. However, as we can see, reflection is nothing that is only restricted to web components built with Polymer.</p>\n<p>If you now think ”<em>This is a horrible hack!</em>” then you’re right. But it seems to be the most comfortable way, compared to creating directives for every single event, to integrate web components with the Angular of today. However, as we know, the Angular team works on a new version of Angular that embraces the power of Web Components technologies by default. Let’s see how these issues are tackled in the Angular of tomorrow.</p>\n<h2 id=\"web-components-and-angular-20\"><a href=\"#web-components-and-angular-20\" aria-label=\"web components and angular 20 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Components and Angular 2.0</h2>\n<p>Angular 2.0 should be able to work with <em>any</em> element. It shouldn’t matter if an element is a native element, or a custom element. It also shouldn’t matter what attributes it defines, or what events it fires. Let me bring up Carmens statement again (and seriously, let it sink in):</p>\n<blockquote>\n<p>Everything is DOM. Angular doesn’t know and shouldn’t know about custom elements.</p>\n</blockquote>\n<p>In order to make this happen, Angular needs a new generalized syntax that unifies native and custom events as well as custom and native property/attribute names. Today we use things like <code class=\"language-text\">ng-click</code> or <code class=\"language-text\">ng-focus</code> to react on events and Angular takes care of triggering a <code class=\"language-text\">$digest</code> for us. However, as we discussed earlier, a custom element could dispatch a custom event that Angular doesn’t know about. To get around this, there’ll be a new template syntax that just works with <em>any</em> event, no matter if custom or native.</p>\n<p>Take a look at the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">(click)</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>doSomething()<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Click me!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>This code executes <code class=\"language-text\">doSomething()</code> on the component when it’s clicked. As we can see, there’s no <code class=\"language-text\">ng-click</code>. Also, <code class=\"language-text\">click</code> could be a custom event name as well. So <code class=\"language-text\">(click)</code> is the same as <code class=\"language-text\">(skip)</code> or <code class=\"language-text\">(foo)</code>. The <code class=\"language-text\">()</code> symbols tell Angular that it’s an event expression. What about attributes and properties?</p>\n<p>As we learned, attributes are always interpreted as strings when it comes to elements (I’m not talking about directives!). However, in an Angular world, we want to be able to pass things like objects to components right? This is why Angular will try to bind to properties by default and falls back to attributes, if there’s no corresponding property. Properties can have any value. And since Angular embraces the declarative way of building apps, it comes with a new template syntax to declare property bindings.</p>\n<p>The following code shows how we can bind a value to a components property in HTML:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">[title]</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>foo<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Again <code class=\"language-text\">title</code> could be anything custom if the underlying element defines it. <code class=\"language-text\">foo</code> can now also be an object or primitive, which wouldn’t be possible with attributes. The <code class=\"language-text\">[]</code> symbols tell Angular that this is a property binding.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>Integrating Web Components with the Angular of today doesn’t <em>really</em> work. It is simply not designed to work with Web Components technologies out of the box. Even if there are ways to make it sort of work, it’ll always be a hack to rely on things like Mutation Observers, especially when keeping in mind that this work-around only works when the element reflects its changes back to its attributes. Also, creating directives for every single event that a custom element could fire, isn’t really a comfortable option.</p>\n<p>However, we shouldn’t forget that this only applies to web components that need to notify the outside world. Components that just need data from the outside world, can be used right away along with Angular without any further hacks.</p>","fields":{"slug":"/posts/integrating-web-components-with-angularjs/","tagSlugs":["/tag/angular/","/tag/web-components/"]},"frontmatter":{"date":"2014-10-25T11:09:47.000Z","description":"Learn how to integrate Web Component Technologies with the AngularJS framework.","tags":["Angular","Web Components"],"title":"Integrating Web Components with AngularJS"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/integrating-web-components-with-angularjs/"}}}