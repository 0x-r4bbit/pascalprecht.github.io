{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/content-identifiers-in-ipfs","webpackCompilationHash":"e6ea3bbe3ddca9ef95da","result":{"data":{"markdownRemark":{"id":"e52e0db7-3522-5246-b97e-7e63cca7e0cc","html":"<p>If you‚Äôve used <a href=\"https://ipfs.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IPFS</a> or watched one or the other talk or tutorial about it, you know that IPFS generates hashes for the data that‚Äôs being added to the network. While it might be obvious why that is (IPFS uses those hashes to identify content in the network), it‚Äôs less obvious how those hashes are being put together.</p>\n<p>Sure, there‚Äôs probably some <a href=\"/posts/future-proofed-hashes-with-multihash/#so-what-are-hashes-again\">hash algorithm applied to data</a>, however it turns out that IPFS goes far beyond that as it uses a combination of <a href=\"https://multiformats.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multiformat</a> protocols to create its <strong>content identifiers</strong> and keep them future-proof, which I think is quite smart as we‚Äôll soon learn.</p>\n<p>One of the Multiformat protocols is <a href=\"https://multiformats.io/multihash/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash</a>. If you haven‚Äôt heard about it before, I recommend heading over to my post on <a href=\"/posts/future-proofed-hashes-with-multihash/\">future-proof cryptographic hashes</a>, which talks about what the protocol is and why it exists. This post builds on top of it.</p>\n<h3 id=\"the-anatomy-of-cids\"><a href=\"#the-anatomy-of-cids\" aria-label=\"the anatomy of cids permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The anatomy of CIDs</h3>\n<p>Let‚Äôs start by getting a hash from IPFS for the content ‚ÄúHello World‚Äù, by piping it through <code class=\"language-text\">ipfs add</code> (you can also create a file with the content first and call <code class=\"language-text\">ipfs add</code> on it as well, but I prefer to save this step):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ echo &quot;Hello World&quot; | ipfs add -n\n$ added QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u</code></pre></div>\n<p>The <code class=\"language-text\">-n</code> option is a cool trick to get a hash from IPFS without actually writing the data to disk. ‚òùüèºAlso notice that IPFS outputs the hash twice. This is because it outputs the hash of the content and the path of the file it resides in. If there‚Äôs no path, like in our case, it uses the hash as path as well.</p>\n<p>Alright, <code class=\"language-text\">QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u</code> it is. This content identifier, or short CID, for ‚ÄúHello World‚Äù will always be the same as long as the content stays the same. While this is not too special, let‚Äôs see what happens if we do the same thing with different content. ‚ÄúHello other world‚Äù for example, will output <code class=\"language-text\">QmcaHpwn3bs9DaeLsrk9ZvVxVcKTPXVWiU1XdrGNW9hpi3</code>. Go, try it yourself! üôÇ</p>\n<p>Noticed something? Right, both hashes start with <code class=\"language-text\">Qm</code>. This is an important characteristic to be aware of - all hashes generated by IPFS start with <code class=\"language-text\">Qm</code>. <strong>Spoiler alert</strong>: this will change <a href=\"https://github.com/ipfs/ipfs/issues/337\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">once IPFS has moved to CIDv1b32</a> which was not the case at the time of writing this post, but more on that later.</p>\n<p>So what‚Äôs this <code class=\"language-text\">Qm</code> prefix all about? The first thing we need to know is that there are multiple versions of CIDs. There‚Äôs CIDv0 and CIDv1. We‚Äôll touch on what the exact differences are in a minute, but whenever we see a hash generated by IPFS that starts with <code class=\"language-text\">Qm</code> we know we‚Äôre dealing with a CIDv0 hash. This is because a CIDv0 is a <a href=\"https://multiformats.io/multihash/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash</a> encoded in <a href=\"https://en.wikipedia.org/wiki/Base58\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Base58</a>.</p>\n<p>Uhm‚Ä¶ so why exactly do we know it‚Äôs a CIDv0? Now it‚Äôs useful to know what a Multihash is (again, if this is new to you read <a href=\"/posts/future-proofed-hashes-with-multihash/\">this post</a> first and come back üôÉ)!</p>\n<p>Since we know it‚Äôs a Multihash, we also know that the first two bytes of the CID represent the hash algorithm type that was used to hash the original data, and the length of the data hash respectively, while the rest of the CID represents the actual hash of the data.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;hash-type&gt; - &lt;hash-length&gt; - &lt;hash-digest&gt;</code></pre></div>\n<p>We can verify this by transforming our ‚ÄúHello World‚Äù hash from Base58 to Base16 (or hexadecimal) and comparing the first byte with the <a href=\"https://github.com/multiformats/multihash/blob/master/hashtable.csv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multihash Table</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">122074410577111096cd817a3faed78630f2245636beded412d3b212a2e09ba593ca</code></pre></div>\n<p>or, to make it more clear</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">12 - 20 - 74410577111096cd817a3faed78630f2245636beded412d3b212a2e09ba593ca\n&lt;hash-type&gt; - &lt;hash-length&gt; - &lt;hash-digest&gt;</code></pre></div>\n<p>The first byte <code class=\"language-text\">0x12</code> represents <code class=\"language-text\">sha2-256</code> in the hash table, which means the hash digest is a SHA-256 hash! But it turns out this is not the whole story. If we try to verify this and use a SHA2-256 function to get a hash for ‚ÄúHello World‚Äù, we‚Äôll notice it doesn‚Äôt really add up‚Ä¶</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ echo Hello World | shasum -a 256\n$ d2a84f4b8b650937ec8f73cd8be2c74add5a911ba64df27458ed8229da804a26</code></pre></div>\n<p>We get <code class=\"language-text\">d2a84f4b8b650937ec8f73cd8be2c74add5a911ba64df27458ed8229da804a26</code> instead of <code class=\"language-text\">74410577111096cd817a3faed78630f2245636beded412d3b212a2e09ba593ca</code>‚Ä¶ so what‚Äôs going on there?</p>\n<p>After a bit of research I‚Äôve learned that IPFS is doing a little bit more work than just hashing the data and creating a multihash out of that. <a href=\"https://twitter.com/daviddias\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">David Dias</a>, team lead and researcher of the IPFS project, puts it quite nicely in <a href=\"https://stackoverflow.com/questions/40998621/how-to-create-an-ipfs-compatible-multihash\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this StackOverflow question</a>:</p>\n<ul>\n<li><strong>IPFS chunks the given file into 256 KiB pieces</strong> - This is not really the case for us right now as we deal with very little data.</li>\n<li><strong>Each chunk goes into a so called ‚ÄúDAG‚Äù</strong> (<a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Directed Acyclic Graph</a>) node inside a so called ‚ÄúUnixfs protobuf‚Äù. More on that in a second.</li>\n<li><strong>Another dag is created</strong> with links to all the chunks.</li>\n</ul>\n<p>‚Ä¶it does what?!</p>\n<p>Yea, that was my reaction too. Lots of words in there that need to be demystified. I‚Äôll go into more details on dags and protocol buffers in future articles, but to keep it very simple for now, IPFS basically serializes some metadata (is it a file? Is it a directory? What‚Äôs the size in bytes?) along with our original data. It then serializes <strong>that</strong> with more metadata (what other data is our data linking to?) and eventually multihashes <strong>that</strong> using <code class=\"language-text\">sha2-256</code> (which just happens to be the default hashing algorithm at the time of writing this post) and puts that in the resulting CID we see on the screen. The APIs mentioned <a href=\"https://github.com/ipfs/faq/issues/208#issuecomment-265221120\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> can be used to play with that stuff.</p>\n<p>So in order to get the hash digest that resides in the CID, we have to get that serialized data and pipe that through <code class=\"language-text\">sha2-256</code>. IPFS‚Äô <code class=\"language-text\">block</code> API lets us do exactly that. First let‚Äôs inspect that serialized data:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ipfs block get QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u | sed -n l\n$ $\n$ \\022\\b\\002\\022\\fHello World$\n$ \\030\\f$</code></pre></div>\n<p>This already shows us that there‚Äôs more than just the ‚ÄúHello World\\n‚Äù data. Now, let‚Äôs pipe this through <code class=\"language-text\">sha2-256</code> and see what happens:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ipfs block get QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u | shasum -a 256\n$ 74410577111096cd817a3faed78630f2245636beded412d3b212a2e09ba593ca</code></pre></div>\n<p>There it is! At this point I‚Äôd like to make a shout-out to <a href=\"https://twitter.com/_alanshaw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Alan</a> and <a href=\"https://stackoverflow.com/users/553092/steven\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Steven</a> who helped me figuring out this <a href=\"https://stackoverflow.com/questions/51655352/how-recreate-a-hash-digest-of-a-multihash-in-ipfs/51658540#51658540\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">last bit</a>.</p>\n<p>Also, if this was a bit hard to follow, no problem. It‚Äôs not required to know what‚Äôs going on behind the scenes to use the tool. Just keep an eye on future articles here that will take a closer look at these things üôÉ.</p>\n<p>Alright, now that we‚Äôve got a better idea of where those <code class=\"language-text\">Qm*</code> hashes come from, let‚Äôs quickly talk about how CIDv0 differs from CIDv1.</p>\n<h3 id=\"differences-in-v1\"><a href=\"#differences-in-v1\" aria-label=\"differences in v1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Differences in v1</h3>\n<p>Content identifiers version 1 encode even more information than its predecessor in a very compact format. While CIDv0 encodes hash type, hash length and hash digest, a CIDv1 can be represented as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;mb&gt;&lt;version&gt;&lt;mc&gt;&lt;mh&gt;</code></pre></div>\n<p>Where</p>\n<ul>\n<li><code class=\"language-text\">mb</code> is a <a href=\"https://github.com/multiformats/multibase\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multibase</a> code - very similar to multihashes, there‚Äôs multibase codes that encode the base encoding type (base16, base32, base58, etc) and the base encoded data itself, into a single string.</li>\n<li><code class=\"language-text\">version</code> is the CID version in use - this makes CIDs upgradable.</li>\n<li><code class=\"language-text\">mc</code> is a <a href=\"https://github.com/multiformats/multicodec\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multicodec</a> type - similar to multihashes and multibases, just for codec types.</li>\n<li><code class=\"language-text\">mh</code> is a Multihash - basically what we‚Äôre getting in CIDv0.</li>\n</ul>\n<p>It turns out that these are very powerful properties. For example, since the base encoding type is part of the CID, one can easily transform CIDs into a base encoding that creates shorter hashes.</p>\n<p>If you want to know what base encoding you‚Äôre dealing with, take a look at the <a href=\"https://github.com/multiformats/multibase/blob/master/multibase.csv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multibase Table</a> provided by the spec. Can you guess what encoding this hash uses? üôÇ</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MTXVsdGliYXNlIGlzIGF3ZXNvbWUhIFxvLw==</code></pre></div>\n<h3 id=\"moving-to-base32\"><a href=\"#moving-to-base32\" aria-label=\"moving to base32 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Moving to Base32</h3>\n<p>At the time of writing this post there was an <a href=\"https://github.com/ipfs/ipfs/issues/337\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ongoing effort</a> to migrate CIDs to CIDv1 and with default base32 encoding (CIDv1b32), while still being backwards compatible with CIDv0. According to the linked issue, this is due to security considerations with sub domains, an <a href=\"https://github.com/mozilla/libdweb/issues/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">experimental protocol handler API</a> and to support legacy URIs.</p>\n<p>This probably raises even more questions, but for now we stop here and let everything sink in we‚Äôve just learned. Here are some of the most important links:</p>\n<ul>\n<li><a href=\"https://multiformats.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Multiformats</a> protocol</li>\n<li><a href=\"https://github.com/ipfs/ipfs/issues/337\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CIDv0 => CIDv1b32 GitHub issue</a></li>\n<li><a href=\"https://stackoverflow.com/questions/40998621/how-to-create-an-ipfs-compatible-multihash\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">‚ÄúHow to create an IPFS compatible multihash‚Äù on StackOverflow</a></li>\n<li><a href=\"https://stackoverflow.com/questions/51655352/how-recreate-a-hash-digest-of-a-multihash-in-ipfs/51658540#51658540\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">‚ÄúHow to recreate the hash digest of a multihash‚Äù on StackOverflow</a></li>\n<li><a href=\"https://github.com/ipld/cid\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IPLD CID Spec</a></li>\n</ul>\n<p>Make sure to check this blog for regular updates as there are more posts planned on everything decentralization, IPFS and more!</p>","fields":{"slug":"/posts/content-identifiers-in-ipfs","tagSlugs":["/tag/ipfs/"]},"frontmatter":{"date":"2018-08-06T07:34:56.000Z","description":"A deep look at content identifiers in the IPFS protocol.","tags":["IPFS"],"title":"Content Identifiers in IPFS"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/content-identifiers-in-ipfs"}}}